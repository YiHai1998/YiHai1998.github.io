# 4种创建线程的方式

```r
基础Thread
实现Runnable
实现Callable
线程池
```

首先呢，Thread 类本质上是实现了 Runnable 接口，代表一个线程的实例。所以我们可以编写一个类，`继承Thread类`，或者直接`实现Runnable接口`，然后再重写下run方法就行了。启动线程的方式就是调用类里边的 start方法。start()方法是一个 native 方法，它的作用就是启动线程，线程会去执行 run()方法中的代码。

还有就是`实现 Callable 接口`，这个接口相当于是Runnable接口的增强版，他的执行代码的方法不是run方法了，是call方法，这个call方法可以有返回值，我们可以创建一个 FutureTask 类的实例对象，通过他的get()方法得到执行结果，不过这里定的执行结果需要跟FutureTask的泛型一致才行，并且call方法还可以抛出异常，通过这些，我们就能很明确的知道线程内部的执行状态。

还有就是通过`线程池`来实现，线程池就是事先将多个线程对象放到一个容器中，当使用的时候就不用 new 线程而是直接去池中拿线程即可，节省了开辟子线程的时间，提高的代码执行效率。 一般创建线程池的话，都是使用个的Executors 类中提供的创建线程池的静态方法。他可以创建4种线程池，有

FixedThreadPool，创建固定大小的线程池，比如线程池容量是10，最多可以同时执行10个线程。

CachedThreadPool，创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于JVM能够创建的最大线程大小，当然线程池里的线程是可以复用的，但是如果在高并发的情况下，这个线程池在会导致运行时内存溢出问题

ScheduledThreadPool，创建一个定时执行的线程池，里边提供了两个方法，FixRate和fixDelay，fixRate就是以固定时间周期执行任务，不管上一个线程是否执行完，fixDelay的话就是以固定的延迟执行任务，就是在上一个任务执行完成之后，延迟一定时间执行。

SingleThreadExecutor，创建一个单线程的线程池，这个线程池同时只能执行一个线程，可以保证线程按顺序执行，保证数据安全。



execute和submit的区别在于，前者没有返回值，只有执行任务。

```
区别：
1、2不能得到返回值。3可以获取返回值
1、2、3都不能控制资源
4可以控制资源，性能稳定。如果有100万个请求进来，每来一个请求就要开启一个线程，很快就会资源耗尽。任何一个高并发系统都是求稳为主！
```



## 线程池:fire:

推荐知乎文章：https://zhuanlan.zhihu.com/p/73990200

**经典面试题**

```
面试问题1：Java的线程池说一下，各个参数的作用，如何进行的？

面试问题2：按线程池内部机制，当提交新任务时，有哪些异常要考虑。

面试问题3：线程池都有哪几种工作队列？

面试问题4：使用无界队列的线程池会导致内存飙升吗？

面试问题5：说说几种常见的线程池及使用场景？
```

### 基本概念

概念：线程池主要是控制运行线程的数量，将待处理任务放到等待队列，然后创建线程执行这些任务。如果超过了最大线程数，则等待。
在操作系统中，我们知道进程的调度是昂贵的，线程虽然没有进程那样宝贵，但是系统依然不可能频繁创建线程又销毁线程，这样会非常影响性能，所以我们需要线程池。

**好处：**

1、降低资源消耗，线程复用：不用一直new新线程，重复利用已经创建的线程来降低线程的创建和销毁开销，节省系统资源。
2、提高响应速度：当任务达到时，不用创建新的线程，直接利用线程池的线程。
3、提高线程的可管理性：可以控制最大并发数，控制线程的创建等。

**什么时候使用线程池？**

1、在系统中如果创建线程+销毁线程的时间大于系统用于完成任务的时间时使用线程。
在web开发中产生的时间如下：网络延迟+创建线程时间+调度的时间+阻塞时间+线程销毁的时间。如果网络延迟、调度的时间、阻塞时间占比比较大，创建线程池也没什么用，此时不一定要线程池。

**构成体系**

Executor→ExecutorService→AbstractExecutorService→ThreadPoolExecutorr。
ThreadPoolExecutor是线程池创建的核心类！类似Arrays、Collections工具类，Executor也有自己的工具类Executors。



### 线程池4种常用创建方式

### 线程池的7个核心配置参数

